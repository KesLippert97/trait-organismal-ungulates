---
title: "Pipeline_Analysis"
output:
  pdf_document: default
  html_document: default
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

# 1 Import data
Our first step is to import packages and data into R. The trait data and OMI data also need to be merged.

### Load packages
```{r Load packages, message=FALSE}
library(ape)
library(dplyr)
library(usdm)
library(caret)
library(corrplot)
library(phylolm)
library(performance)
library(see)
library(gridExtra)
library(tidyverse)
library(naniar)
```

### Import data
The datasets can be found in different GitHub repositories. The ungulate
dataset and tree can be found in the trait-organismal-ungulates repository. 
The OMI data is found in the trait-geo-diverse-ungulates repository.
```{r import data}
ungulatesData <- read.csv("https://raw.githubusercontent.com/naturalis/trait-organismal-ungulates/master/data/CSV/ungulatesTraits.csv")
omi <- read.csv("https://raw.githubusercontent.com/naturalis/trait-geo-diverse-ungulates/master/results/OMI/niche_traits.csv")
tree <- read.tree("https://raw.githubusercontent.com/naturalis/trait-organismal-ungulates/master/data/phylogeny/ungulates.tree")
```

### Merge datasets
The ungulate data and OMI data have to be merged into one dataset. The EoL-ID is
removed and the data is merged by the canonical name (present in both the
datasets). The last step is to replace the spaces in the canonical name with
underscores, to match the species names in the tree.
```{r merge data}
ungulatesData <- ungulatesData[2:60]
names(omi)[names(omi)=="X"] <- "CanonicalName"
dataset <- merge(ungulatesData, omi, by="CanonicalName")
dataset$CanonicalName <- gsub(" ", "_", dataset$CanonicalName)

# Clean up the global environment 
rm(ungulatesData, omi)
```

# 2 Preprocessing
### Equalize species in tree and dataset
To start, 'Equus asinus' is renamed to the 'Equus africanus' in the tree, to
match the dataset. The species that aren't in the tree are dropped from the
dataset. The species that aren't in the dataset are dropped from the tree.
```{r check if names match between dataset and tree, results='hide'}
# Changed Equus asinus to Equus africanus in the tree 
tree$tip.label[tree$tip.label=="Equus_asinus"] <- "Equus_africanus"

# Check Which species aren't in the tree
dropRows <- setdiff(dataset$CanonicalName, tree$tip.label)

# Drop rows that aren't in the tree (check manually if these are domesticated)
row.names(dataset) <- dataset$CanonicalName
dataset <- dataset[!(row.names(dataset) %in% dropRows), ]

# Drop tips that aren't in dataset
dropTips <- setdiff(tree$tip.label, dataset$CanonicalName)
tree <- drop.tip(tree, dropTips)

# Final check to see if there are any differences
setdiff(dataset$CanonicalName, tree$tip.label)
setdiff(tree$tip.label, dataset$CanonicalName)

rm(dropRows, dropTips)
```


### Miscellaneous preprocessing
The dots in the column names are replaced with underscores. After that, the
traits that consist of more than 100 missing values, traits that have no
information gain and traits that are almost identical to other traits are
removed.
```{r misc preprocessing}
# Rename column with dots in the name
names(dataset)[names(dataset)=="X21.1_PopulationDensity_n.km2"] <- "X21.1_PopulationDensity_n_km2"

# Remove traits that contain >50% missing variables
# Check the number and % missing values for all variables in the dataset 
miss_var_summary(dataset) 


## Remove columns with >50% NA
# let's experiment with the 0.5 threshold, might be changed
dataset <- dataset[, which(colMeans(!is.na(dataset)) > 0.5)]


# Remove traits without any information gain (only consist of one value)
#Identify which variables have zero variance
nearZeroVar(dataset)

dataset <- subset(dataset, select = -c(nearZeroVar(dataset)))

# Remove traits that are almost identical to other traits
#TODO: Hard code remove columns that are scaled copies of other columns
dataset <- subset(dataset, select = -c(X5.1_AdultBodyMass_g, CarryWeight, PullStrength, X5.3_NeonateBodyMass_g))


#Remove columns that contain non-data taxonomic information
dataset <- subset(dataset, select = -c(CanonicalName, BinomialName, Order, Family, Genus, Species))
```

### Set as factors
Some of the columns are not seen as categorical, but as numeric. These must be converted to factors.
```{r as factor}

#TODO: Check if all columns are represented 
dataset$Domestication <- as.factor(dataset$Domestication)
dataset$X1.1_ActivityCycle <- as.factor(dataset$X1.1_ActivityCycle)
dataset$X6.1_DietBreadth <- as.factor(dataset$X6.1_DietBreadth)
dataset$X12.1_HabitatBreadth <- as.factor(dataset$X12.1_HabitatBreadth)
dataset$X6.2_TrophicLevel <- as.factor(dataset$X6.2_TrophicLevel)
dataset$Diet <- as.factor(dataset$Diet)
dataset$Sociality <- as.factor(dataset$Sociality)
dataset$SocialHierarchy <- as.factor(dataset$SocialHierarchy)
dataset$NumMales <- as.factor(dataset$NumMales)
dataset$MatingSystem <- as.factor(dataset$MatingSystem)
dataset$YearRoundBreeding <- as.factor(dataset$YearRoundBreeding)
dataset$DevelopmentStrategy <- as.factor(dataset$DevelopmentStrategy)
dataset$HeadOrnaments <- as.factor(dataset$HeadOrnaments)
dataset$NaturalPredators <- as.factor(dataset$NaturalPredators)

```

# 3 VIF-Analysis
There is probably collinearity present amongst the traits in the dataset.
Collinearity can lead to bias in the model, so we must correct for this. This can be done by running a variable inflation factor analysis (VIF). This script only requires the 'dataset' variable and after it is run, it will output the 'predictors' variable.
```{r VIF, results='markup'}
# Do the VIF analysis
## BEGIN VALUES
# Take only the numeric predictors and remove the dependent variable
startPredictors <- dplyr::select_if(dataset, is.numeric)
startPredictors$Domestication <- NULL

# The first correlation matrix is a visualization of the dataset without the removal of any traits. There is a lot of collinearity present.
matrix <- cor(startPredictors, use = "pairwise.complete.obs")
corrplot(matrix, type="lower", order = "hclust", tl.pos = "l", tl.col = "black", tl.cex = 0.4)


## CHECK CORRELATION MATRIX
# The corrplot package is used to visualize the collinearity between the traits, using the correlation matrix. With the findCorrelation() function, the columns with the highest collinearity are found. By visualizing the matrix, the outcome of the findCorrelation function can be easily checked. The VIF function can be run to easily check if the results are still infinite. A cutoff value of .83 is chosen, using trial and error.
matrix <- cor(startPredictors, use = "pairwise.complete.obs")
delColumn <- findCorrelation(matrix, cutoff = .83, verbose = FALSE, exact=FALSE)
startPredictors <- startPredictors[,-c(delColumn)]

vif(startPredictors)

## INSERT ADULTBODYMASS
# The set of predictors is declared for the VIF analysis, and a last check for collinearity using the visualized matrix is done. During the first round, AdultBodyMass was removed due to a high collinearity with other traits. However, because Adultbodymass is hypothesized to be a biologically relevant trait, it will be reinserted in this step.
vifPredictors <- cbind(dataset$X5.1_AdultBodyMass_g, startPredictors)
colnames(vifPredictors)[1] <- "X5.1_AdultBodyMass_g"

# Check VIF -> Adultbodymass is highly correlated with the other traits.
vif(vifPredictors)

# CarryWeight has a high collinearity with AdultBodyMass (both inf). Since AdultBodyMass
#  is hypothesized to be biologically relevant, CarryWeight will be removed.
vifPredictors$CarryWeight <- NULL
vif(vifPredictors)

# Check correlation matrix
# A visualization of the dataset after the cutoff value is implemented and 
# AdultBodyMass is added.
matrix <- cor(vifPredictors, use = "pairwise.complete.obs")
corrplot(matrix, type="lower", order = "hclust", tl.pos = "l", tl.col = "black", tl.cex = 0.7)


## VIF ANALYSIS
# Check VIF -> PETWarmestQuarter has highest VIF value above 10
# Remove PETWarmestQuarter
vif(vifPredictors)
vifPredictors$PETWarmestQuarter <- NULL

# Check VIF -> bio3 has highest VIF value above 10
# Remove bio3
vif(vifPredictors)
vifPredictors$bio3 <- NULL

# Check VIF -> bio2 has highest VIF value above 10
# Remove bio2
vif(vifPredictors)
vifPredictors$bio2 <- NULL

# Check VIF -> bio14 has highest VIF value above 10
# Remove bio14
vif(vifPredictors)
vifPredictors$bio14 <- NULL

# Check VIF -> PETDriestQuarter has highest VIF value above 10
vif(vifPredictors)
vifPredictors$PETDriestQuarter <- NULL

# Check VIF -> AVGFoodConsumption has highest VIF value above 10
vif(vifPredictors)
vifPredictors$AVGFoodConsumption <- NULL

# Check VIF -> X13.1_AdultHeadBodyLen_mm has highest VIF value above 10
vif(vifPredictors)
vifPredictors$X13.1_AdultHeadBodyLen_mm <- NULL

# Check VIF -> All VIF values under 10 (except AdultBodyMass, which is 11)
vif(vifPredictors)


## FINAL PREDICTOR SET
# Final set of numeric predictors, containing:  X5.1_AdultBodyMass_g, X9.1_GestationLen_d,
# X15.1_LitterSize, X17.1_MaxLongevity_m, X21.1_PopulationDensity_n_km2, 
# X23.1_SexualMaturityAge_d, X10.2_SocialGrpSize, X25.1_WeaningAge_d, Lifespan,
# AVGMovingSpeed, AVGTravelDistance, Aspect, BulkDensity, ClayPercentage, minTempWarmest,
# PETseasonality, PETWettestQuarter, OrganicCarbon, PhCaCL, Slope, bio15, bio18, bio19
vifPredictors

## FINAL VALUES
# The final correlation matrix is the final product after removing all highly correlated
# traits. 
matrix <- cor(vifPredictors, use = "pairwise.complete.obs")
corrplot(matrix, type="lower", order = "hclust", tl.pos = "l", tl.col = "black", tl.cex = 0.7)

## REMOVE VARIABLES
rm(startPredictors, matrix, delColumn)

# Final VIF values
vif(vifPredictors)
```

# 4 Model Selection
A Generalized Linear Model (GLM) must be made. The Domestication column is
used as the dependent variable, and the other columns are the predictor
variables. For the model selection the phylolm package and phyloglmstep function
are required.
```{r model selection, results='hide'}
# Add factor predictors to numeric predictors
factors <- dplyr::select_if(dataset, is.factor)
predictors <- cbind(vifPredictors, factors)

# Do the model selection
source("ModelSelection.R")

# Remove unneeded variables
rm(vifPredictors, factors)
```


# 5 Modelling analysis
The phylogenetic generalized linear modelling analysis optimizes the model. The
function phyloglm from the phylolm package is used for this.
```{r model analysis, results='hide'}
# Converting dependent variable to binary state
# Domesticated = 1, wild = 0
dataset$Domestication[dataset$Domestication==2] <- 0

# Construct model
phyloGLM <- phyloglm(formula = finalFormula, data = dataset, phy = tree, method = "logistic_MPLE", btol = 36, log.alpha.bound = 4)
summary(phyloGLM)
```


# 6 Model evaluation
The model is evaluated to check whether the model constructed, is still in
compliance with the assumptions that have to be met when performing a GLM. The
package 'performance' is used for this. The function 'check_model()' is used for
a comprehensive model check. This function is not appropriate for models
including phylogeny. The check will still be done, but the resulting
interpretation may be skewed.
```{r model evaluation}
GLM <- glm(formula = finalFormula, data = dataset, family = gaussian)

check_model(GLM)
```


# 7 Plots
The results are visualized using different plots.

```{r plots}
source("Plots.R")

```